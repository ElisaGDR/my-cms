"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tiptap-markdown";
exports.ids = ["vendor-chunks/tiptap-markdown"];
exports.modules = {

/***/ "(ssr)/./node_modules/tiptap-markdown/dist/tiptap-markdown.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tiptap-markdown/dist/tiptap-markdown.es.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Markdown: () => (/* binding */ Markdown)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-markdown */ \"(ssr)/./node_modules/prosemirror-markdown/dist/index.js\");\n/* harmony import */ var markdown_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! markdown-it */ \"(ssr)/./node_modules/markdown-it/index.mjs\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var markdown_it_task_lists__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! markdown-it-task-lists */ \"(ssr)/./node_modules/markdown-it-task-lists/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\n\n\n\n\nconst MarkdownTightLists = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Extension.create({\n  name: \"markdownTightLists\",\n  addOptions: () => ({\n    tight: true,\n    tightClass: \"tight\",\n    listTypes: [\"bulletList\", \"orderedList\"]\n  }),\n  addGlobalAttributes() {\n    return [{\n      types: this.options.listTypes,\n      attributes: {\n        tight: {\n          default: this.options.tight,\n          parseHTML: (element) => element.getAttribute(\"data-tight\") === \"true\" || !element.querySelector(\"p\"),\n          renderHTML: (attributes) => ({\n            class: attributes.tight ? this.options.tightClass : null,\n            \"data-tight\": attributes.tight ? \"true\" : null\n          })\n        }\n      }\n    }];\n  },\n  addCommands() {\n    var _this = this;\n    return {\n      toggleTight: function() {\n        let tight = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        return (_ref) => {\n          let {\n            editor,\n            commands\n          } = _ref;\n          function toggleTight(name) {\n            if (!editor.isActive(name)) {\n              return false;\n            }\n            const attrs = editor.getAttributes(name);\n            return commands.updateAttributes(name, {\n              tight: tight !== null && tight !== void 0 ? tight : !(attrs !== null && attrs !== void 0 && attrs.tight)\n            });\n          }\n          return _this.options.listTypes.some((name) => toggleTight(name));\n        };\n      }\n    };\n  }\n});\nconst md = (0,markdown_it__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\nfunction scanDelims(text, pos) {\n  md.inline.State.prototype.scanDelims.call({\n    src: text,\n    posMax: text.length\n  });\n  const state = new md.inline.State(text, null, null, []);\n  return state.scanDelims(pos, true);\n}\nfunction shiftDelim(text, delim, start, offset) {\n  let res = text.substring(0, start) + text.substring(start + delim.length);\n  res = res.substring(0, start + offset) + delim + res.substring(start + offset);\n  return res;\n}\nfunction trimStart(text, delim, from, to) {\n  let pos = from, res = text;\n  while (pos < to) {\n    if (scanDelims(res, pos).can_open) {\n      break;\n    }\n    res = shiftDelim(res, delim, pos, 1);\n    pos++;\n  }\n  return {\n    text: res,\n    from: pos,\n    to\n  };\n}\nfunction trimEnd(text, delim, from, to) {\n  let pos = to, res = text;\n  while (pos > from) {\n    if (scanDelims(res, pos).can_close) {\n      break;\n    }\n    res = shiftDelim(res, delim, pos, -1);\n    pos--;\n  }\n  return {\n    text: res,\n    from,\n    to: pos\n  };\n}\nfunction trimInline(text, delim, from, to) {\n  let state = {\n    text,\n    from,\n    to\n  };\n  state = trimStart(state.text, delim, state.from, state.to);\n  state = trimEnd(state.text, delim, state.from, state.to);\n  if (state.to - state.from < delim.length + 1) {\n    state.text = state.text.substring(0, state.from) + state.text.substring(state.to + delim.length);\n  }\n  return state.text;\n}\nclass MarkdownSerializerState extends prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.MarkdownSerializerState {\n  constructor(nodes, marks, options) {\n    super(nodes, marks, options !== null && options !== void 0 ? options : {});\n    __publicField(this, \"inTable\", false);\n    this.inlines = [];\n  }\n  render(node, parent, index) {\n    super.render(node, parent, index);\n    const top = this.inlines[this.inlines.length - 1];\n    if (top !== null && top !== void 0 && top.start && top !== null && top !== void 0 && top.end) {\n      const {\n        delimiter,\n        start,\n        end\n      } = this.normalizeInline(top);\n      this.out = trimInline(this.out, delimiter, start, end);\n      this.inlines.pop();\n    }\n  }\n  markString(mark, open, parent, index) {\n    const info = this.marks[mark.type.name];\n    if (info.expelEnclosingWhitespace) {\n      if (open) {\n        this.inlines.push({\n          start: this.out.length,\n          delimiter: info.open\n        });\n      } else {\n        const top = this.inlines.pop();\n        this.inlines.push({\n          ...top,\n          end: this.out.length\n        });\n      }\n    }\n    return super.markString(mark, open, parent, index);\n  }\n  normalizeInline(inline) {\n    let {\n      start,\n      end\n    } = inline;\n    while (this.out.charAt(start).match(/\\s/)) {\n      start++;\n    }\n    return {\n      ...inline,\n      start\n    };\n  }\n}\nconst HTMLMark = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"markdownHTMLMark\",\n  /**\n   * @return {{markdown: MarkdownMarkSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: {\n          open(state, mark) {\n            var _getMarkTags$, _getMarkTags;\n            if (!this.editor.storage.markdown.options.html) {\n              console.warn(`Tiptap Markdown: \"${mark.type.name}\" mark is only available in html mode`);\n              return \"\";\n            }\n            return (_getMarkTags$ = (_getMarkTags = getMarkTags(mark)) === null || _getMarkTags === void 0 ? void 0 : _getMarkTags[0]) !== null && _getMarkTags$ !== void 0 ? _getMarkTags$ : \"\";\n          },\n          close(state, mark) {\n            var _getMarkTags$2, _getMarkTags2;\n            if (!this.editor.storage.markdown.options.html) {\n              return \"\";\n            }\n            return (_getMarkTags$2 = (_getMarkTags2 = getMarkTags(mark)) === null || _getMarkTags2 === void 0 ? void 0 : _getMarkTags2[1]) !== null && _getMarkTags$2 !== void 0 ? _getMarkTags$2 : \"\";\n          }\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nfunction getMarkTags(mark) {\n  const schema = mark.type.schema;\n  const node = schema.text(\" \", [mark]);\n  const html = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_4__.getHTMLFromFragment)(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), schema);\n  const match = html.match(/^(<.*?>) (<\\/.*?>)$/);\n  return match ? [match[1], match[2]] : null;\n}\nfunction elementFromString(value) {\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n}\nfunction escapeHTML(value) {\n  return value === null || value === void 0 ? void 0 : value.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction extractElement(node) {\n  const parent = node.parentElement;\n  const prepend = parent.cloneNode();\n  while (parent.firstChild && parent.firstChild !== node) {\n    prepend.appendChild(parent.firstChild);\n  }\n  if (prepend.childNodes.length > 0) {\n    parent.parentElement.insertBefore(prepend, parent);\n  }\n  parent.parentElement.insertBefore(node, parent);\n  if (parent.childNodes.length === 0) {\n    parent.remove();\n  }\n}\nfunction unwrapElement(node) {\n  const parent = node.parentNode;\n  while (node.firstChild)\n    parent.insertBefore(node.firstChild, node);\n  parent.removeChild(node);\n}\nconst HTMLNode = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"markdownHTMLNode\",\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node, parent) {\n          if (this.editor.storage.markdown.options.html) {\n            state.write(serializeHTML(node, parent));\n          } else {\n            console.warn(`Tiptap Markdown: \"${node.type.name}\" node is only available in html mode`);\n            state.write(`[${node.type.name}]`);\n          }\n          if (node.isBlock) {\n            state.closeBlock(node);\n          }\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nfunction serializeHTML(node, parent) {\n  const schema = node.type.schema;\n  const html = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_4__.getHTMLFromFragment)(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), schema);\n  if (node.isBlock && (parent instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_1__.Fragment || parent.type.name === schema.topNodeType.name)) {\n    return formatBlock(html);\n  }\n  return html;\n}\nfunction formatBlock(html) {\n  const dom = elementFromString(html);\n  const element = dom.firstElementChild;\n  element.innerHTML = element.innerHTML.trim() ? `\n${element.innerHTML}\n` : `\n`;\n  return element.outerHTML;\n}\nconst Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"blockquote\"\n});\nconst Blockquote$1 = Blockquote.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.nodes.blockquote,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"bulletList\"\n});\nconst BulletList$1 = BulletList.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node) {\n          return state.renderList(node, \"  \", () => (this.editor.storage.markdown.options.bulletListMarker || \"-\") + \" \");\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"codeBlock\"\n});\nconst CodeBlock$1 = CodeBlock.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node) {\n          state.write(\"```\" + (node.attrs.language || \"\") + \"\\n\");\n          state.text(node.textContent, false);\n          state.ensureNewLine();\n          state.write(\"```\");\n          state.closeBlock(node);\n        },\n        parse: {\n          setup(markdownit2) {\n            var _this$options$languag;\n            markdownit2.set({\n              langPrefix: (_this$options$languag = this.options.languageClassPrefix) !== null && _this$options$languag !== void 0 ? _this$options$languag : \"language-\"\n            });\n          },\n          updateDOM(element) {\n            element.innerHTML = element.innerHTML.replace(/\\n<\\/code><\\/pre>/g, \"</code></pre>\");\n          }\n        }\n      }\n    };\n  }\n});\nconst HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"hardBreak\"\n});\nconst HardBreak$1 = HardBreak.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node, parent, index) {\n          for (let i = index + 1; i < parent.childCount; i++)\n            if (parent.child(i).type != node.type) {\n              state.write(state.inTable ? HTMLNode.storage.markdown.serialize.call(this, state, node, parent) : \"\\\\\\n\");\n              return;\n            }\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"heading\"\n});\nconst Heading$1 = Heading.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.nodes.heading,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"horizontalRule\"\n});\nconst HorizontalRule$1 = HorizontalRule.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.nodes.horizontal_rule,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Image = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"image\"\n});\nconst Image$1 = Image.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.nodes.image,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"listItem\"\n});\nconst ListItem$1 = ListItem.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.nodes.list_item,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"orderedList\"\n});\nfunction findIndexOfAdjacentNode(node, parent, index) {\n  let i = 0;\n  for (; index - i > 0; i++) {\n    if (parent.child(index - i - 1).type.name !== node.type.name) {\n      break;\n    }\n  }\n  return i;\n}\nconst OrderedList$1 = OrderedList.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node, parent, index) {\n          const start = node.attrs.start || 1;\n          const maxW = String(start + node.childCount - 1).length;\n          const space = state.repeat(\" \", maxW + 2);\n          const adjacentIndex = findIndexOfAdjacentNode(node, parent, index);\n          const separator = adjacentIndex % 2 ? \") \" : \". \";\n          state.renderList(node, space, (i) => {\n            const nStr = String(start + i);\n            return state.repeat(\" \", maxW - nStr.length) + nStr + separator;\n          });\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"paragraph\"\n});\nconst Paragraph$1 = Paragraph.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.nodes.paragraph,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nfunction childNodes(node) {\n  var _node$content$content, _node$content;\n  return (_node$content$content = node === null || node === void 0 || (_node$content = node.content) === null || _node$content === void 0 ? void 0 : _node$content.content) !== null && _node$content$content !== void 0 ? _node$content$content : [];\n}\nconst Table = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"table\"\n});\nconst Table$1 = Table.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node, parent) {\n          if (!isMarkdownSerializable(node)) {\n            HTMLNode.storage.markdown.serialize.call(this, state, node, parent);\n            return;\n          }\n          state.inTable = true;\n          node.forEach((row, p, i) => {\n            state.write(\"| \");\n            row.forEach((col, p2, j) => {\n              if (j) {\n                state.write(\" | \");\n              }\n              const cellContent = col.firstChild;\n              if (cellContent.textContent.trim()) {\n                state.renderInline(cellContent);\n              }\n            });\n            state.write(\" |\");\n            state.ensureNewLine();\n            if (!i) {\n              const delimiterRow = Array.from({\n                length: row.childCount\n              }).map(() => \"---\").join(\" | \");\n              state.write(`| ${delimiterRow} |`);\n              state.ensureNewLine();\n            }\n          });\n          state.closeBlock(node);\n          state.inTable = false;\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nfunction hasSpan(node) {\n  return node.attrs.colspan > 1 || node.attrs.rowspan > 1;\n}\nfunction isMarkdownSerializable(node) {\n  const rows = childNodes(node);\n  const firstRow = rows[0];\n  const bodyRows = rows.slice(1);\n  if (childNodes(firstRow).some((cell) => cell.type.name !== \"tableHeader\" || hasSpan(cell) || cell.childCount > 1)) {\n    return false;\n  }\n  if (bodyRows.some((row) => childNodes(row).some((cell) => cell.type.name === \"tableHeader\" || hasSpan(cell) || cell.childCount > 1))) {\n    return false;\n  }\n  return true;\n}\nconst TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"taskItem\"\n});\nconst TaskItem$1 = TaskItem.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node) {\n          const check = node.attrs.checked ? \"[x]\" : \"[ ]\";\n          state.write(`${check} `);\n          state.renderContent(node);\n        },\n        parse: {\n          updateDOM(element) {\n            [...element.querySelectorAll(\".task-list-item\")].forEach((item) => {\n              const input = item.querySelector(\"input\");\n              item.setAttribute(\"data-type\", \"taskItem\");\n              if (input) {\n                item.setAttribute(\"data-checked\", input.checked);\n                input.remove();\n              }\n            });\n          }\n        }\n      }\n    };\n  }\n});\nconst TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"taskList\"\n});\nconst TaskList$1 = TaskList.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: BulletList$1.storage.markdown.serialize,\n        parse: {\n          setup(markdownit2) {\n            markdownit2.use(markdown_it_task_lists__WEBPACK_IMPORTED_MODULE_2__);\n          },\n          updateDOM(element) {\n            [...element.querySelectorAll(\".contains-task-list\")].forEach((list) => {\n              list.setAttribute(\"data-type\", \"taskList\");\n            });\n          }\n        }\n      }\n    };\n  }\n});\nconst Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Node.create({\n  name: \"text\"\n});\nconst Text$1 = Text.extend({\n  /**\n   * @return {{markdown: MarkdownNodeSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize(state, node) {\n          state.text(escapeHTML(node.text));\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"bold\"\n});\nconst Bold$1 = Bold.extend({\n  /**\n   * @return {{markdown: MarkdownMarkSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.marks.strong,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"code\"\n});\nconst Code$1 = Code.extend({\n  /**\n   * @return {{markdown: MarkdownMarkSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.marks.code,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"italic\"\n});\nconst Italic$1 = Italic.extend({\n  /**\n   * @return {{markdown: MarkdownMarkSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.marks.em,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"link\"\n});\nconst Link$1 = Link.extend({\n  /**\n   * @return {{markdown: MarkdownMarkSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: prosemirror_markdown__WEBPACK_IMPORTED_MODULE_5__.defaultMarkdownSerializer.marks.link,\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Mark.create({\n  name: \"strike\"\n});\nconst Strike$1 = Strike.extend({\n  /**\n   * @return {{markdown: MarkdownMarkSpec}}\n   */\n  addStorage() {\n    return {\n      markdown: {\n        serialize: {\n          open: \"~~\",\n          close: \"~~\",\n          expelEnclosingWhitespace: true\n        },\n        parse: {\n          // handled by markdown-it\n        }\n      }\n    };\n  }\n});\nconst markdownExtensions = [Blockquote$1, BulletList$1, CodeBlock$1, HardBreak$1, Heading$1, HorizontalRule$1, HTMLNode, Image$1, ListItem$1, OrderedList$1, Paragraph$1, Table$1, TaskItem$1, TaskList$1, Text$1, Bold$1, Code$1, HTMLMark, Italic$1, Link$1, Strike$1];\nfunction getMarkdownSpec(extension) {\n  var _extension$storage, _markdownExtensions$f;\n  const markdownSpec = (_extension$storage = extension.storage) === null || _extension$storage === void 0 ? void 0 : _extension$storage.markdown;\n  const defaultMarkdownSpec = (_markdownExtensions$f = markdownExtensions.find((e) => e.name === extension.name)) === null || _markdownExtensions$f === void 0 ? void 0 : _markdownExtensions$f.storage.markdown;\n  if (markdownSpec || defaultMarkdownSpec) {\n    return {\n      ...defaultMarkdownSpec,\n      ...markdownSpec\n    };\n  }\n  return null;\n}\nclass MarkdownSerializer {\n  constructor(editor) {\n    /**\n     * @type {import('@tiptap/core').Editor}\n     */\n    __publicField(this, \"editor\", null);\n    this.editor = editor;\n  }\n  serialize(content) {\n    const state = new MarkdownSerializerState(this.nodes, this.marks, {\n      hardBreakNodeName: HardBreak$1.name\n    });\n    state.renderContent(content);\n    return state.out;\n  }\n  get nodes() {\n    var _this$editor$extensio;\n    return {\n      ...Object.fromEntries(Object.keys(this.editor.schema.nodes).map((name) => [name, this.serializeNode(HTMLNode)])),\n      ...Object.fromEntries((_this$editor$extensio = this.editor.extensionManager.extensions.filter((extension) => extension.type === \"node\" && this.serializeNode(extension)).map((extension) => [extension.name, this.serializeNode(extension)])) !== null && _this$editor$extensio !== void 0 ? _this$editor$extensio : [])\n    };\n  }\n  get marks() {\n    var _this$editor$extensio2;\n    return {\n      ...Object.fromEntries(Object.keys(this.editor.schema.marks).map((name) => [name, this.serializeMark(HTMLMark)])),\n      ...Object.fromEntries((_this$editor$extensio2 = this.editor.extensionManager.extensions.filter((extension) => extension.type === \"mark\" && this.serializeMark(extension)).map((extension) => [extension.name, this.serializeMark(extension)])) !== null && _this$editor$extensio2 !== void 0 ? _this$editor$extensio2 : [])\n    };\n  }\n  serializeNode(node) {\n    var _getMarkdownSpec;\n    return (_getMarkdownSpec = getMarkdownSpec(node)) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.serialize) === null || _getMarkdownSpec === void 0 ? void 0 : _getMarkdownSpec.bind({\n      editor: this.editor,\n      options: node.options\n    });\n  }\n  serializeMark(mark) {\n    var _getMarkdownSpec2;\n    const serialize = (_getMarkdownSpec2 = getMarkdownSpec(mark)) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.serialize;\n    return serialize ? {\n      ...serialize,\n      open: typeof serialize.open === \"function\" ? serialize.open.bind({\n        editor: this.editor,\n        options: mark.options\n      }) : serialize.open,\n      close: typeof serialize.close === \"function\" ? serialize.close.bind({\n        editor: this.editor,\n        options: mark.options\n      }) : serialize.close\n    } : null;\n  }\n}\nclass MarkdownParser {\n  constructor(editor, _ref) {\n    /**\n     * @type {import('@tiptap/core').Editor}\n     */\n    __publicField(this, \"editor\", null);\n    /**\n     * @type {markdownit}\n     */\n    __publicField(this, \"md\", null);\n    let {\n      html,\n      linkify,\n      breaks\n    } = _ref;\n    this.editor = editor;\n    this.md = this.withPatchedRenderer((0,markdown_it__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      html,\n      linkify,\n      breaks\n    }));\n  }\n  parse(content) {\n    let {\n      inline\n    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (typeof content === \"string\") {\n      this.editor.extensionManager.extensions.forEach((extension) => {\n        var _getMarkdownSpec;\n        return (_getMarkdownSpec = getMarkdownSpec(extension)) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.parse) === null || _getMarkdownSpec === void 0 || (_getMarkdownSpec = _getMarkdownSpec.setup) === null || _getMarkdownSpec === void 0 ? void 0 : _getMarkdownSpec.call({\n          editor: this.editor,\n          options: extension.options\n        }, this.md);\n      });\n      const renderedHTML = this.md.render(content);\n      const element = elementFromString(renderedHTML);\n      this.editor.extensionManager.extensions.forEach((extension) => {\n        var _getMarkdownSpec2;\n        return (_getMarkdownSpec2 = getMarkdownSpec(extension)) === null || _getMarkdownSpec2 === void 0 || (_getMarkdownSpec2 = _getMarkdownSpec2.parse) === null || _getMarkdownSpec2 === void 0 || (_getMarkdownSpec2 = _getMarkdownSpec2.updateDOM) === null || _getMarkdownSpec2 === void 0 ? void 0 : _getMarkdownSpec2.call({\n          editor: this.editor,\n          options: extension.options\n        }, element);\n      });\n      this.normalizeDOM(element, {\n        inline,\n        content\n      });\n      return element.innerHTML;\n    }\n    return content;\n  }\n  normalizeDOM(node, _ref2) {\n    let {\n      inline,\n      content\n    } = _ref2;\n    this.normalizeBlocks(node);\n    node.querySelectorAll(\"*\").forEach((el) => {\n      var _el$nextSibling;\n      if (((_el$nextSibling = el.nextSibling) === null || _el$nextSibling === void 0 ? void 0 : _el$nextSibling.nodeType) === Node.TEXT_NODE && !el.closest(\"pre\")) {\n        el.nextSibling.textContent = el.nextSibling.textContent.replace(/^\\n/, \"\");\n      }\n    });\n    if (inline) {\n      this.normalizeInline(node, content);\n    }\n    return node;\n  }\n  normalizeBlocks(node) {\n    const blocks = Object.values(this.editor.schema.nodes).filter((node2) => node2.isBlock);\n    const selector = blocks.map((block) => {\n      var _block$spec$parseDOM;\n      return (_block$spec$parseDOM = block.spec.parseDOM) === null || _block$spec$parseDOM === void 0 ? void 0 : _block$spec$parseDOM.map((spec) => spec.tag);\n    }).flat().filter(Boolean).join(\",\");\n    if (!selector) {\n      return;\n    }\n    [...node.querySelectorAll(selector)].forEach((el) => {\n      if (el.parentElement.matches(\"p\")) {\n        extractElement(el);\n      }\n    });\n  }\n  normalizeInline(node, content) {\n    var _node$firstElementChi;\n    if ((_node$firstElementChi = node.firstElementChild) !== null && _node$firstElementChi !== void 0 && _node$firstElementChi.matches(\"p\")) {\n      var _content$match$, _content$match, _content$match$2, _content$match2;\n      const firstParagraph = node.firstElementChild;\n      const {\n        nextElementSibling\n      } = firstParagraph;\n      const startSpaces = (_content$match$ = (_content$match = content.match(/^\\s+/)) === null || _content$match === void 0 ? void 0 : _content$match[0]) !== null && _content$match$ !== void 0 ? _content$match$ : \"\";\n      const endSpaces = !nextElementSibling ? (_content$match$2 = (_content$match2 = content.match(/\\s+$/)) === null || _content$match2 === void 0 ? void 0 : _content$match2[0]) !== null && _content$match$2 !== void 0 ? _content$match$2 : \"\" : \"\";\n      if (content.match(/^\\n\\n/)) {\n        firstParagraph.innerHTML = `${firstParagraph.innerHTML}${endSpaces}`;\n        return;\n      }\n      unwrapElement(firstParagraph);\n      node.innerHTML = `${startSpaces}${node.innerHTML}${endSpaces}`;\n    }\n  }\n  /**\n   * @param {markdownit} md\n   */\n  withPatchedRenderer(md2) {\n    const withoutNewLine = (renderer) => function() {\n      const rendered = renderer(...arguments);\n      if (rendered === \"\\n\") {\n        return rendered;\n      }\n      if (rendered[rendered.length - 1] === \"\\n\") {\n        return rendered.slice(0, -1);\n      }\n      return rendered;\n    };\n    md2.renderer.rules.hardbreak = withoutNewLine(md2.renderer.rules.hardbreak);\n    md2.renderer.rules.softbreak = withoutNewLine(md2.renderer.rules.softbreak);\n    md2.renderer.rules.fence = withoutNewLine(md2.renderer.rules.fence);\n    md2.renderer.rules.code_block = withoutNewLine(md2.renderer.rules.code_block);\n    md2.renderer.renderToken = withoutNewLine(md2.renderer.renderToken.bind(md2.renderer));\n    return md2;\n  }\n}\nconst MarkdownClipboard = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Extension.create({\n  name: \"markdownClipboard\",\n  addOptions() {\n    return {\n      transformPastedText: false,\n      transformCopiedText: false\n    };\n  },\n  addProseMirrorPlugins() {\n    return [new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_3__.PluginKey(\"markdownClipboard\"),\n      props: {\n        clipboardTextParser: (text, context, plainText) => {\n          if (plainText || !this.options.transformPastedText) {\n            return null;\n          }\n          const parsed = this.editor.storage.markdown.parser.parse(text, {\n            inline: true\n          });\n          return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.editor.schema).parseSlice(elementFromString(parsed), {\n            preserveWhitespace: true,\n            context\n          });\n        },\n        /**\n         * @param {import('prosemirror-model').Slice} slice\n         */\n        clipboardTextSerializer: (slice) => {\n          if (!this.options.transformCopiedText) {\n            return null;\n          }\n          return this.editor.storage.markdown.serializer.serialize(slice.content);\n        }\n      }\n    })];\n  }\n});\nconst Markdown = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.Extension.create({\n  name: \"markdown\",\n  priority: 50,\n  addOptions() {\n    return {\n      html: true,\n      tightLists: true,\n      tightListClass: \"tight\",\n      bulletListMarker: \"-\",\n      linkify: false,\n      breaks: false,\n      transformPastedText: false,\n      transformCopiedText: false\n    };\n  },\n  addCommands() {\n    const commands = _tiptap_core__WEBPACK_IMPORTED_MODULE_4__.extensions.Commands.config.addCommands();\n    return {\n      setContent: (content, emitUpdate, parseOptions) => (props) => {\n        return commands.setContent(props.editor.storage.markdown.parser.parse(content), emitUpdate, parseOptions)(props);\n      },\n      insertContentAt: (range, content, options) => (props) => {\n        return commands.insertContentAt(range, props.editor.storage.markdown.parser.parse(content, {\n          inline: true\n        }), options)(props);\n      }\n    };\n  },\n  onBeforeCreate() {\n    this.editor.storage.markdown = {\n      options: {\n        ...this.options\n      },\n      parser: new MarkdownParser(this.editor, this.options),\n      serializer: new MarkdownSerializer(this.editor),\n      getMarkdown: () => {\n        return this.editor.storage.markdown.serializer.serialize(this.editor.state.doc);\n      }\n    };\n    this.editor.options.initialContent = this.editor.options.content;\n    this.editor.options.content = this.editor.storage.markdown.parser.parse(this.editor.options.content);\n  },\n  onCreate() {\n    this.editor.options.content = this.editor.options.initialContent;\n    delete this.editor.options.initialContent;\n  },\n  addStorage() {\n    return {\n      /// storage will be defined in onBeforeCreate() to prevent initial object overriding\n    };\n  },\n  addExtensions() {\n    return [MarkdownTightLists.configure({\n      tight: this.options.tightLists,\n      tightClass: this.options.tightListClass\n    }), MarkdownClipboard.configure({\n      transformPastedText: this.options.transformPastedText,\n      transformCopiedText: this.options.transformCopiedText\n    })];\n  }\n});\n\n//# sourceMappingURL=tiptap-markdown.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGlwdGFwLW1hcmtkb3duL2Rpc3QvdGlwdGFwLW1hcmtkb3duLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDZ0c7QUFDdUI7QUFDbEY7QUFDa0I7QUFDSDtBQUNDO0FBQ3JELDJCQUEyQixtREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsV0FBVyx1REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUVBQXlCO0FBQy9EO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLG1EQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCLG9EQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUdDO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXN1YXJpb1xcUHJvamVjdHNcXGhhcmJvdXJcXG15LWNtc1xcbm9kZV9tb2R1bGVzXFx0aXB0YXAtbWFya2Rvd25cXGRpc3RcXHRpcHRhcC1tYXJrZG93bi5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5pbXBvcnQgeyBFeHRlbnNpb24sIE1hcmssIGdldEhUTUxGcm9tRnJhZ21lbnQsIE5vZGUgYXMgTm9kZSQxLCBleHRlbnNpb25zIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgTWFya2Rvd25TZXJpYWxpemVyU3RhdGUgYXMgTWFya2Rvd25TZXJpYWxpemVyU3RhdGUkMSwgZGVmYXVsdE1hcmtkb3duU2VyaWFsaXplciB9IGZyb20gXCJwcm9zZW1pcnJvci1tYXJrZG93blwiO1xuaW1wb3J0IG1hcmtkb3duaXQgZnJvbSBcIm1hcmtkb3duLWl0XCI7XG5pbXBvcnQgeyBGcmFnbWVudCwgRE9NUGFyc2VyIH0gZnJvbSBcIkB0aXB0YXAvcG0vbW9kZWxcIjtcbmltcG9ydCB0YXNrTGlzdFBsdWdpbiBmcm9tIFwibWFya2Rvd24taXQtdGFzay1saXN0c1wiO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tIFwiQHRpcHRhcC9wbS9zdGF0ZVwiO1xuY29uc3QgTWFya2Rvd25UaWdodExpc3RzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwibWFya2Rvd25UaWdodExpc3RzXCIsXG4gIGFkZE9wdGlvbnM6ICgpID0+ICh7XG4gICAgdGlnaHQ6IHRydWUsXG4gICAgdGlnaHRDbGFzczogXCJ0aWdodFwiLFxuICAgIGxpc3RUeXBlczogW1wiYnVsbGV0TGlzdFwiLCBcIm9yZGVyZWRMaXN0XCJdXG4gIH0pLFxuICBhZGRHbG9iYWxBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbe1xuICAgICAgdHlwZXM6IHRoaXMub3B0aW9ucy5saXN0VHlwZXMsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHRpZ2h0OiB7XG4gICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLnRpZ2h0LFxuICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10aWdodFwiKSA9PT0gXCJ0cnVlXCIgfHwgIWVsZW1lbnQucXVlcnlTZWxlY3RvcihcInBcIiksXG4gICAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+ICh7XG4gICAgICAgICAgICBjbGFzczogYXR0cmlidXRlcy50aWdodCA/IHRoaXMub3B0aW9ucy50aWdodENsYXNzIDogbnVsbCxcbiAgICAgICAgICAgIFwiZGF0YS10aWdodFwiOiBhdHRyaWJ1dGVzLnRpZ2h0ID8gXCJ0cnVlXCIgOiBudWxsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dO1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVUaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCB0aWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIChfcmVmKSA9PiB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGNvbW1hbmRzXG4gICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgZnVuY3Rpb24gdG9nZ2xlVGlnaHQobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNBY3RpdmUobmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBlZGl0b3IuZ2V0QXR0cmlidXRlcyhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51cGRhdGVBdHRyaWJ1dGVzKG5hbWUsIHtcbiAgICAgICAgICAgICAgdGlnaHQ6IHRpZ2h0ICE9PSBudWxsICYmIHRpZ2h0ICE9PSB2b2lkIDAgPyB0aWdodCA6ICEoYXR0cnMgIT09IG51bGwgJiYgYXR0cnMgIT09IHZvaWQgMCAmJiBhdHRycy50aWdodClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5saXN0VHlwZXMuc29tZSgobmFtZSkgPT4gdG9nZ2xlVGlnaHQobmFtZSkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgbWQgPSBtYXJrZG93bml0KCk7XG5mdW5jdGlvbiBzY2FuRGVsaW1zKHRleHQsIHBvcykge1xuICBtZC5pbmxpbmUuU3RhdGUucHJvdG90eXBlLnNjYW5EZWxpbXMuY2FsbCh7XG4gICAgc3JjOiB0ZXh0LFxuICAgIHBvc01heDogdGV4dC5sZW5ndGhcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gbmV3IG1kLmlubGluZS5TdGF0ZSh0ZXh0LCBudWxsLCBudWxsLCBbXSk7XG4gIHJldHVybiBzdGF0ZS5zY2FuRGVsaW1zKHBvcywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBzaGlmdERlbGltKHRleHQsIGRlbGltLCBzdGFydCwgb2Zmc2V0KSB7XG4gIGxldCByZXMgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydCkgKyB0ZXh0LnN1YnN0cmluZyhzdGFydCArIGRlbGltLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5zdWJzdHJpbmcoMCwgc3RhcnQgKyBvZmZzZXQpICsgZGVsaW0gKyByZXMuc3Vic3RyaW5nKHN0YXJ0ICsgb2Zmc2V0KTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydCh0ZXh0LCBkZWxpbSwgZnJvbSwgdG8pIHtcbiAgbGV0IHBvcyA9IGZyb20sIHJlcyA9IHRleHQ7XG4gIHdoaWxlIChwb3MgPCB0bykge1xuICAgIGlmIChzY2FuRGVsaW1zKHJlcywgcG9zKS5jYW5fb3Blbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlcyA9IHNoaWZ0RGVsaW0ocmVzLCBkZWxpbSwgcG9zLCAxKTtcbiAgICBwb3MrKztcbiAgfVxuICByZXR1cm4ge1xuICAgIHRleHQ6IHJlcyxcbiAgICBmcm9tOiBwb3MsXG4gICAgdG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyaW1FbmQodGV4dCwgZGVsaW0sIGZyb20sIHRvKSB7XG4gIGxldCBwb3MgPSB0bywgcmVzID0gdGV4dDtcbiAgd2hpbGUgKHBvcyA+IGZyb20pIHtcbiAgICBpZiAoc2NhbkRlbGltcyhyZXMsIHBvcykuY2FuX2Nsb3NlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzID0gc2hpZnREZWxpbShyZXMsIGRlbGltLCBwb3MsIC0xKTtcbiAgICBwb3MtLTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRleHQ6IHJlcyxcbiAgICBmcm9tLFxuICAgIHRvOiBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyaW1JbmxpbmUodGV4dCwgZGVsaW0sIGZyb20sIHRvKSB7XG4gIGxldCBzdGF0ZSA9IHtcbiAgICB0ZXh0LFxuICAgIGZyb20sXG4gICAgdG9cbiAgfTtcbiAgc3RhdGUgPSB0cmltU3RhcnQoc3RhdGUudGV4dCwgZGVsaW0sIHN0YXRlLmZyb20sIHN0YXRlLnRvKTtcbiAgc3RhdGUgPSB0cmltRW5kKHN0YXRlLnRleHQsIGRlbGltLCBzdGF0ZS5mcm9tLCBzdGF0ZS50byk7XG4gIGlmIChzdGF0ZS50byAtIHN0YXRlLmZyb20gPCBkZWxpbS5sZW5ndGggKyAxKSB7XG4gICAgc3RhdGUudGV4dCA9IHN0YXRlLnRleHQuc3Vic3RyaW5nKDAsIHN0YXRlLmZyb20pICsgc3RhdGUudGV4dC5zdWJzdHJpbmcoc3RhdGUudG8gKyBkZWxpbS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50ZXh0O1xufVxuY2xhc3MgTWFya2Rvd25TZXJpYWxpemVyU3RhdGUgZXh0ZW5kcyBNYXJrZG93blNlcmlhbGl6ZXJTdGF0ZSQxIHtcbiAgY29uc3RydWN0b3Iobm9kZXMsIG1hcmtzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobm9kZXMsIG1hcmtzLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluVGFibGVcIiwgZmFsc2UpO1xuICAgIHRoaXMuaW5saW5lcyA9IFtdO1xuICB9XG4gIHJlbmRlcihub2RlLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgc3VwZXIucmVuZGVyKG5vZGUsIHBhcmVudCwgaW5kZXgpO1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuaW5saW5lc1t0aGlzLmlubGluZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRvcCAhPT0gbnVsbCAmJiB0b3AgIT09IHZvaWQgMCAmJiB0b3Auc3RhcnQgJiYgdG9wICE9PSBudWxsICYmIHRvcCAhPT0gdm9pZCAwICYmIHRvcC5lbmQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVsaW1pdGVyLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kXG4gICAgICB9ID0gdGhpcy5ub3JtYWxpemVJbmxpbmUodG9wKTtcbiAgICAgIHRoaXMub3V0ID0gdHJpbUlubGluZSh0aGlzLm91dCwgZGVsaW1pdGVyLCBzdGFydCwgZW5kKTtcbiAgICAgIHRoaXMuaW5saW5lcy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgbWFya1N0cmluZyhtYXJrLCBvcGVuLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgIGlmIChpbmZvLmV4cGVsRW5jbG9zaW5nV2hpdGVzcGFjZSkge1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgdGhpcy5pbmxpbmVzLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLm91dC5sZW5ndGgsXG4gICAgICAgICAgZGVsaW1pdGVyOiBpbmZvLm9wZW5cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLmlubGluZXMucG9wKCk7XG4gICAgICAgIHRoaXMuaW5saW5lcy5wdXNoKHtcbiAgICAgICAgICAuLi50b3AsXG4gICAgICAgICAgZW5kOiB0aGlzLm91dC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5tYXJrU3RyaW5nKG1hcmssIG9wZW4sIHBhcmVudCwgaW5kZXgpO1xuICB9XG4gIG5vcm1hbGl6ZUlubGluZShpbmxpbmUpIHtcbiAgICBsZXQge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9ID0gaW5saW5lO1xuICAgIHdoaWxlICh0aGlzLm91dC5jaGFyQXQoc3RhcnQpLm1hdGNoKC9cXHMvKSkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmlubGluZSxcbiAgICAgIHN0YXJ0XG4gICAgfTtcbiAgfVxufVxuY29uc3QgSFRNTE1hcmsgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwibWFya2Rvd25IVE1MTWFya1wiLFxuICAvKipcbiAgICogQHJldHVybiB7e21hcmtkb3duOiBNYXJrZG93bk1hcmtTcGVjfX1cbiAgICovXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtkb3duOiB7XG4gICAgICAgIHNlcmlhbGl6ZToge1xuICAgICAgICAgIG9wZW4oc3RhdGUsIG1hcmspIHtcbiAgICAgICAgICAgIHZhciBfZ2V0TWFya1RhZ3MkLCBfZ2V0TWFya1RhZ3M7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLnN0b3JhZ2UubWFya2Rvd24ub3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGlwdGFwIE1hcmtkb3duOiBcIiR7bWFyay50eXBlLm5hbWV9XCIgbWFyayBpcyBvbmx5IGF2YWlsYWJsZSBpbiBodG1sIG1vZGVgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKF9nZXRNYXJrVGFncyQgPSAoX2dldE1hcmtUYWdzID0gZ2V0TWFya1RhZ3MobWFyaykpID09PSBudWxsIHx8IF9nZXRNYXJrVGFncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldE1hcmtUYWdzWzBdKSAhPT0gbnVsbCAmJiBfZ2V0TWFya1RhZ3MkICE9PSB2b2lkIDAgPyBfZ2V0TWFya1RhZ3MkIDogXCJcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlKHN0YXRlLCBtYXJrKSB7XG4gICAgICAgICAgICB2YXIgX2dldE1hcmtUYWdzJDIsIF9nZXRNYXJrVGFnczI7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLnN0b3JhZ2UubWFya2Rvd24ub3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChfZ2V0TWFya1RhZ3MkMiA9IChfZ2V0TWFya1RhZ3MyID0gZ2V0TWFya1RhZ3MobWFyaykpID09PSBudWxsIHx8IF9nZXRNYXJrVGFnczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRNYXJrVGFnczJbMV0pICE9PSBudWxsICYmIF9nZXRNYXJrVGFncyQyICE9PSB2b2lkIDAgPyBfZ2V0TWFya1RhZ3MkMiA6IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0TWFya1RhZ3MobWFyaykge1xuICBjb25zdCBzY2hlbWEgPSBtYXJrLnR5cGUuc2NoZW1hO1xuICBjb25zdCBub2RlID0gc2NoZW1hLnRleHQoXCIgXCIsIFttYXJrXSk7XG4gIGNvbnN0IGh0bWwgPSBnZXRIVE1MRnJvbUZyYWdtZW50KEZyYWdtZW50LmZyb20obm9kZSksIHNjaGVtYSk7XG4gIGNvbnN0IG1hdGNoID0gaHRtbC5tYXRjaCgvXig8Lio/PikgKDxcXC8uKj8+KSQvKTtcbiAgcmV0dXJuIG1hdGNoID8gW21hdGNoWzFdLCBtYXRjaFsyXV0gOiBudWxsO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWUpIHtcbiAgY29uc3Qgd3JhcHBlZFZhbHVlID0gYDxib2R5PiR7dmFsdWV9PC9ib2R5PmA7XG4gIHJldHVybiBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh3cmFwcGVkVmFsdWUsIFwidGV4dC9odG1sXCIpLmJvZHk7XG59XG5mdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG59XG5mdW5jdGlvbiBleHRyYWN0RWxlbWVudChub2RlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgY29uc3QgcHJlcGVuZCA9IHBhcmVudC5jbG9uZU5vZGUoKTtcbiAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBub2RlKSB7XG4gICAgcHJlcGVuZC5hcHBlbmRDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gIH1cbiAgaWYgKHByZXBlbmQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgcGFyZW50LnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHByZXBlbmQsIHBhcmVudCk7XG4gIH1cbiAgcGFyZW50LnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhcmVudCk7XG4gIGlmIChwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICBwYXJlbnQucmVtb3ZlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpXG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLmZpcnN0Q2hpbGQsIG5vZGUpO1xuICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5jb25zdCBIVE1MTm9kZSA9IE5vZGUkMS5jcmVhdGUoe1xuICBuYW1lOiBcIm1hcmtkb3duSFRNTE5vZGVcIixcbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2Rvd246IHtcbiAgICAgICAgc2VyaWFsaXplKHN0YXRlLCBub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5lZGl0b3Iuc3RvcmFnZS5tYXJrZG93bi5vcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKHNlcmlhbGl6ZUhUTUwobm9kZSwgcGFyZW50KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGlwdGFwIE1hcmtkb3duOiBcIiR7bm9kZS50eXBlLm5hbWV9XCIgbm9kZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBodG1sIG1vZGVgKTtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKGBbJHtub2RlLnR5cGUubmFtZX1dYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuZnVuY3Rpb24gc2VyaWFsaXplSFRNTChub2RlLCBwYXJlbnQpIHtcbiAgY29uc3Qgc2NoZW1hID0gbm9kZS50eXBlLnNjaGVtYTtcbiAgY29uc3QgaHRtbCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQuZnJvbShub2RlKSwgc2NoZW1hKTtcbiAgaWYgKG5vZGUuaXNCbG9jayAmJiAocGFyZW50IGluc3RhbmNlb2YgRnJhZ21lbnQgfHwgcGFyZW50LnR5cGUubmFtZSA9PT0gc2NoZW1hLnRvcE5vZGVUeXBlLm5hbWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEJsb2NrKGh0bWwpO1xuICB9XG4gIHJldHVybiBodG1sO1xufVxuZnVuY3Rpb24gZm9ybWF0QmxvY2soaHRtbCkge1xuICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKTtcbiAgY29uc3QgZWxlbWVudCA9IGRvbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTC50cmltKCkgPyBgXG4ke2VsZW1lbnQuaW5uZXJIVE1MfVxuYCA6IGBcbmA7XG4gIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbn1cbmNvbnN0IEJsb2NrcXVvdGUgPSBOb2RlJDEuY3JlYXRlKHtcbiAgbmFtZTogXCJibG9ja3F1b3RlXCJcbn0pO1xuY29uc3QgQmxvY2txdW90ZSQxID0gQmxvY2txdW90ZS5leHRlbmQoe1xuICAvKipcbiAgICogQHJldHVybiB7e21hcmtkb3duOiBNYXJrZG93bk5vZGVTcGVjfX1cbiAgICovXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtkb3duOiB7XG4gICAgICAgIHNlcmlhbGl6ZTogZGVmYXVsdE1hcmtkb3duU2VyaWFsaXplci5ub2Rlcy5ibG9ja3F1b3RlLFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgQnVsbGV0TGlzdCA9IE5vZGUkMS5jcmVhdGUoe1xuICBuYW1lOiBcImJ1bGxldExpc3RcIlxufSk7XG5jb25zdCBCdWxsZXRMaXN0JDEgPSBCdWxsZXRMaXN0LmV4dGVuZCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHt7bWFya2Rvd246IE1hcmtkb3duTm9kZVNwZWN9fVxuICAgKi9cbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2Rvd246IHtcbiAgICAgICAgc2VyaWFsaXplKHN0YXRlLCBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnJlbmRlckxpc3Qobm9kZSwgXCIgIFwiLCAoKSA9PiAodGhpcy5lZGl0b3Iuc3RvcmFnZS5tYXJrZG93bi5vcHRpb25zLmJ1bGxldExpc3RNYXJrZXIgfHwgXCItXCIpICsgXCIgXCIpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgQ29kZUJsb2NrID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwiY29kZUJsb2NrXCJcbn0pO1xuY29uc3QgQ29kZUJsb2NrJDEgPSBDb2RlQmxvY2suZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemUoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZShcImBgYFwiICsgKG5vZGUuYXR0cnMubGFuZ3VhZ2UgfHwgXCJcIikgKyBcIlxcblwiKTtcbiAgICAgICAgICBzdGF0ZS50ZXh0KG5vZGUudGV4dENvbnRlbnQsIGZhbHNlKTtcbiAgICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgICAgc3RhdGUud3JpdGUoXCJgYGBcIik7XG4gICAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICBzZXR1cChtYXJrZG93bml0Mikge1xuICAgICAgICAgICAgdmFyIF90aGlzJG9wdGlvbnMkbGFuZ3VhZztcbiAgICAgICAgICAgIG1hcmtkb3duaXQyLnNldCh7XG4gICAgICAgICAgICAgIGxhbmdQcmVmaXg6IChfdGhpcyRvcHRpb25zJGxhbmd1YWcgPSB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VDbGFzc1ByZWZpeCkgIT09IG51bGwgJiYgX3RoaXMkb3B0aW9ucyRsYW5ndWFnICE9PSB2b2lkIDAgPyBfdGhpcyRvcHRpb25zJGxhbmd1YWcgOiBcImxhbmd1YWdlLVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwZGF0ZURPTShlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcbjxcXC9jb2RlPjxcXC9wcmU+L2csIFwiPC9jb2RlPjwvcHJlPlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IEhhcmRCcmVhayA9IE5vZGUkMS5jcmVhdGUoe1xuICBuYW1lOiBcImhhcmRCcmVha1wiXG59KTtcbmNvbnN0IEhhcmRCcmVhayQxID0gSGFyZEJyZWFrLmV4dGVuZCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHt7bWFya2Rvd246IE1hcmtkb3duTm9kZVNwZWN9fVxuICAgKi9cbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2Rvd246IHtcbiAgICAgICAgc2VyaWFsaXplKHN0YXRlLCBub2RlLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkKGkpLnR5cGUgIT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLndyaXRlKHN0YXRlLmluVGFibGUgPyBIVE1MTm9kZS5zdG9yYWdlLm1hcmtkb3duLnNlcmlhbGl6ZS5jYWxsKHRoaXMsIHN0YXRlLCBub2RlLCBwYXJlbnQpIDogXCJcXFxcXFxuXCIpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiB7XG4gICAgICAgICAgLy8gaGFuZGxlZCBieSBtYXJrZG93bi1pdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBIZWFkaW5nID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaGVhZGluZ1wiXG59KTtcbmNvbnN0IEhlYWRpbmckMSA9IEhlYWRpbmcuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemU6IGRlZmF1bHRNYXJrZG93blNlcmlhbGl6ZXIubm9kZXMuaGVhZGluZyxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IEhvcml6b250YWxSdWxlID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwiaG9yaXpvbnRhbFJ1bGVcIlxufSk7XG5jb25zdCBIb3Jpem9udGFsUnVsZSQxID0gSG9yaXpvbnRhbFJ1bGUuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemU6IGRlZmF1bHRNYXJrZG93blNlcmlhbGl6ZXIubm9kZXMuaG9yaXpvbnRhbF9ydWxlLFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgSW1hZ2UgPSBOb2RlJDEuY3JlYXRlKHtcbiAgbmFtZTogXCJpbWFnZVwiXG59KTtcbmNvbnN0IEltYWdlJDEgPSBJbWFnZS5leHRlbmQoe1xuICAvKipcbiAgICogQHJldHVybiB7e21hcmtkb3duOiBNYXJrZG93bk5vZGVTcGVjfX1cbiAgICovXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtkb3duOiB7XG4gICAgICAgIHNlcmlhbGl6ZTogZGVmYXVsdE1hcmtkb3duU2VyaWFsaXplci5ub2Rlcy5pbWFnZSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IExpc3RJdGVtID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlzdEl0ZW1cIlxufSk7XG5jb25zdCBMaXN0SXRlbSQxID0gTGlzdEl0ZW0uZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemU6IGRlZmF1bHRNYXJrZG93blNlcmlhbGl6ZXIubm9kZXMubGlzdF9pdGVtLFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgT3JkZXJlZExpc3QgPSBOb2RlJDEuY3JlYXRlKHtcbiAgbmFtZTogXCJvcmRlcmVkTGlzdFwiXG59KTtcbmZ1bmN0aW9uIGZpbmRJbmRleE9mQWRqYWNlbnROb2RlKG5vZGUsIHBhcmVudCwgaW5kZXgpIHtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaW5kZXggLSBpID4gMDsgaSsrKSB7XG4gICAgaWYgKHBhcmVudC5jaGlsZChpbmRleCAtIGkgLSAxKS50eXBlLm5hbWUgIT09IG5vZGUudHlwZS5uYW1lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5jb25zdCBPcmRlcmVkTGlzdCQxID0gT3JkZXJlZExpc3QuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemUoc3RhdGUsIG5vZGUsIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IG5vZGUuYXR0cnMuc3RhcnQgfHwgMTtcbiAgICAgICAgICBjb25zdCBtYXhXID0gU3RyaW5nKHN0YXJ0ICsgbm9kZS5jaGlsZENvdW50IC0gMSkubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHNwYWNlID0gc3RhdGUucmVwZWF0KFwiIFwiLCBtYXhXICsgMik7XG4gICAgICAgICAgY29uc3QgYWRqYWNlbnRJbmRleCA9IGZpbmRJbmRleE9mQWRqYWNlbnROb2RlKG5vZGUsIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IGFkamFjZW50SW5kZXggJSAyID8gXCIpIFwiIDogXCIuIFwiO1xuICAgICAgICAgIHN0YXRlLnJlbmRlckxpc3Qobm9kZSwgc3BhY2UsIChpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuU3RyID0gU3RyaW5nKHN0YXJ0ICsgaSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUucmVwZWF0KFwiIFwiLCBtYXhXIC0gblN0ci5sZW5ndGgpICsgblN0ciArIHNlcGFyYXRvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IFBhcmFncmFwaCA9IE5vZGUkMS5jcmVhdGUoe1xuICBuYW1lOiBcInBhcmFncmFwaFwiXG59KTtcbmNvbnN0IFBhcmFncmFwaCQxID0gUGFyYWdyYXBoLmV4dGVuZCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHt7bWFya2Rvd246IE1hcmtkb3duTm9kZVNwZWN9fVxuICAgKi9cbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2Rvd246IHtcbiAgICAgICAgc2VyaWFsaXplOiBkZWZhdWx0TWFya2Rvd25TZXJpYWxpemVyLm5vZGVzLnBhcmFncmFwaCxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmZ1bmN0aW9uIGNoaWxkTm9kZXMobm9kZSkge1xuICB2YXIgX25vZGUkY29udGVudCRjb250ZW50LCBfbm9kZSRjb250ZW50O1xuICByZXR1cm4gKF9ub2RlJGNvbnRlbnQkY29udGVudCA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwIHx8IChfbm9kZSRjb250ZW50ID0gbm9kZS5jb250ZW50KSA9PT0gbnVsbCB8fCBfbm9kZSRjb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRjb250ZW50LmNvbnRlbnQpICE9PSBudWxsICYmIF9ub2RlJGNvbnRlbnQkY29udGVudCAhPT0gdm9pZCAwID8gX25vZGUkY29udGVudCRjb250ZW50IDogW107XG59XG5jb25zdCBUYWJsZSA9IE5vZGUkMS5jcmVhdGUoe1xuICBuYW1lOiBcInRhYmxlXCJcbn0pO1xuY29uc3QgVGFibGUkMSA9IFRhYmxlLmV4dGVuZCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHt7bWFya2Rvd246IE1hcmtkb3duTm9kZVNwZWN9fVxuICAgKi9cbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2Rvd246IHtcbiAgICAgICAgc2VyaWFsaXplKHN0YXRlLCBub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIWlzTWFya2Rvd25TZXJpYWxpemFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIEhUTUxOb2RlLnN0b3JhZ2UubWFya2Rvd24uc2VyaWFsaXplLmNhbGwodGhpcywgc3RhdGUsIG5vZGUsIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmluVGFibGUgPSB0cnVlO1xuICAgICAgICAgIG5vZGUuZm9yRWFjaCgocm93LCBwLCBpKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShcInwgXCIpO1xuICAgICAgICAgICAgcm93LmZvckVhY2goKGNvbCwgcDIsIGopID0+IHtcbiAgICAgICAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZShcIiB8IFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjZWxsQ29udGVudCA9IGNvbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICBpZiAoY2VsbENvbnRlbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVuZGVySW5saW5lKGNlbGxDb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShcIiB8XCIpO1xuICAgICAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlclJvdyA9IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogcm93LmNoaWxkQ291bnRcbiAgICAgICAgICAgICAgfSkubWFwKCgpID0+IFwiLS0tXCIpLmpvaW4oXCIgfCBcIik7XG4gICAgICAgICAgICAgIHN0YXRlLndyaXRlKGB8ICR7ZGVsaW1pdGVyUm93fSB8YCk7XG4gICAgICAgICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICAgIHN0YXRlLmluVGFibGUgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmZ1bmN0aW9uIGhhc1NwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5hdHRycy5jb2xzcGFuID4gMSB8fCBub2RlLmF0dHJzLnJvd3NwYW4gPiAxO1xufVxuZnVuY3Rpb24gaXNNYXJrZG93blNlcmlhbGl6YWJsZShub2RlKSB7XG4gIGNvbnN0IHJvd3MgPSBjaGlsZE5vZGVzKG5vZGUpO1xuICBjb25zdCBmaXJzdFJvdyA9IHJvd3NbMF07XG4gIGNvbnN0IGJvZHlSb3dzID0gcm93cy5zbGljZSgxKTtcbiAgaWYgKGNoaWxkTm9kZXMoZmlyc3RSb3cpLnNvbWUoKGNlbGwpID0+IGNlbGwudHlwZS5uYW1lICE9PSBcInRhYmxlSGVhZGVyXCIgfHwgaGFzU3BhbihjZWxsKSB8fCBjZWxsLmNoaWxkQ291bnQgPiAxKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYm9keVJvd3Muc29tZSgocm93KSA9PiBjaGlsZE5vZGVzKHJvdykuc29tZSgoY2VsbCkgPT4gY2VsbC50eXBlLm5hbWUgPT09IFwidGFibGVIZWFkZXJcIiB8fCBoYXNTcGFuKGNlbGwpIHx8IGNlbGwuY2hpbGRDb3VudCA+IDEpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFRhc2tJdGVtID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFza0l0ZW1cIlxufSk7XG5jb25zdCBUYXNrSXRlbSQxID0gVGFza0l0ZW0uZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemUoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgICBjb25zdCBjaGVjayA9IG5vZGUuYXR0cnMuY2hlY2tlZCA/IFwiW3hdXCIgOiBcIlsgXVwiO1xuICAgICAgICAgIHN0YXRlLndyaXRlKGAke2NoZWNrfSBgKTtcbiAgICAgICAgICBzdGF0ZS5yZW5kZXJDb250ZW50KG5vZGUpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIHVwZGF0ZURPTShlbGVtZW50KSB7XG4gICAgICAgICAgICBbLi4uZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhc2stbGlzdC1pdGVtXCIpXS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaXRlbS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIsIFwidGFza0l0ZW1cIik7XG4gICAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwiZGF0YS1jaGVja2VkXCIsIGlucHV0LmNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIGlucHV0LnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IFRhc2tMaXN0ID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGFza0xpc3RcIlxufSk7XG5jb25zdCBUYXNrTGlzdCQxID0gVGFza0xpc3QuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemU6IEJ1bGxldExpc3QkMS5zdG9yYWdlLm1hcmtkb3duLnNlcmlhbGl6ZSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICBzZXR1cChtYXJrZG93bml0Mikge1xuICAgICAgICAgICAgbWFya2Rvd25pdDIudXNlKHRhc2tMaXN0UGx1Z2luKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwZGF0ZURPTShlbGVtZW50KSB7XG4gICAgICAgICAgICBbLi4uZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNvbnRhaW5zLXRhc2stbGlzdFwiKV0uZm9yRWFjaCgobGlzdCkgPT4ge1xuICAgICAgICAgICAgICBsaXN0LnNldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiLCBcInRhc2tMaXN0XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBUZXh0ID0gTm9kZSQxLmNyZWF0ZSh7XG4gIG5hbWU6IFwidGV4dFwiXG59KTtcbmNvbnN0IFRleHQkMSA9IFRleHQuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25Ob2RlU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemUoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgICBzdGF0ZS50ZXh0KGVzY2FwZUhUTUwobm9kZS50ZXh0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiB7XG4gICAgICAgICAgLy8gaGFuZGxlZCBieSBtYXJrZG93bi1pdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBCb2xkID0gTWFyay5jcmVhdGUoe1xuICBuYW1lOiBcImJvbGRcIlxufSk7XG5jb25zdCBCb2xkJDEgPSBCb2xkLmV4dGVuZCh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHt7bWFya2Rvd246IE1hcmtkb3duTWFya1NwZWN9fVxuICAgKi9cbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFya2Rvd246IHtcbiAgICAgICAgc2VyaWFsaXplOiBkZWZhdWx0TWFya2Rvd25TZXJpYWxpemVyLm1hcmtzLnN0cm9uZyxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IENvZGUgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwiY29kZVwiXG59KTtcbmNvbnN0IENvZGUkMSA9IENvZGUuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25NYXJrU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemU6IGRlZmF1bHRNYXJrZG93blNlcmlhbGl6ZXIubWFya3MuY29kZSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJpdGFsaWNcIlxufSk7XG5jb25zdCBJdGFsaWMkMSA9IEl0YWxpYy5leHRlbmQoe1xuICAvKipcbiAgICogQHJldHVybiB7e21hcmtkb3duOiBNYXJrZG93bk1hcmtTcGVjfX1cbiAgICovXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtkb3duOiB7XG4gICAgICAgIHNlcmlhbGl6ZTogZGVmYXVsdE1hcmtkb3duU2VyaWFsaXplci5tYXJrcy5lbSxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IExpbmsgPSBNYXJrLmNyZWF0ZSh7XG4gIG5hbWU6IFwibGlua1wiXG59KTtcbmNvbnN0IExpbmskMSA9IExpbmsuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge3ttYXJrZG93bjogTWFya2Rvd25NYXJrU3BlY319XG4gICAqL1xuICBhZGRTdG9yYWdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bjoge1xuICAgICAgICBzZXJpYWxpemU6IGRlZmF1bHRNYXJrZG93blNlcmlhbGl6ZXIubWFya3MubGluayxcbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAvLyBoYW5kbGVkIGJ5IG1hcmtkb3duLWl0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcbmNvbnN0IFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcbiAgbmFtZTogXCJzdHJpa2VcIlxufSk7XG5jb25zdCBTdHJpa2UkMSA9IFN0cmlrZS5leHRlbmQoe1xuICAvKipcbiAgICogQHJldHVybiB7e21hcmtkb3duOiBNYXJrZG93bk1hcmtTcGVjfX1cbiAgICovXG4gIGFkZFN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmtkb3duOiB7XG4gICAgICAgIHNlcmlhbGl6ZToge1xuICAgICAgICAgIG9wZW46IFwifn5cIixcbiAgICAgICAgICBjbG9zZTogXCJ+flwiLFxuICAgICAgICAgIGV4cGVsRW5jbG9zaW5nV2hpdGVzcGFjZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZToge1xuICAgICAgICAgIC8vIGhhbmRsZWQgYnkgbWFya2Rvd24taXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgbWFya2Rvd25FeHRlbnNpb25zID0gW0Jsb2NrcXVvdGUkMSwgQnVsbGV0TGlzdCQxLCBDb2RlQmxvY2skMSwgSGFyZEJyZWFrJDEsIEhlYWRpbmckMSwgSG9yaXpvbnRhbFJ1bGUkMSwgSFRNTE5vZGUsIEltYWdlJDEsIExpc3RJdGVtJDEsIE9yZGVyZWRMaXN0JDEsIFBhcmFncmFwaCQxLCBUYWJsZSQxLCBUYXNrSXRlbSQxLCBUYXNrTGlzdCQxLCBUZXh0JDEsIEJvbGQkMSwgQ29kZSQxLCBIVE1MTWFyaywgSXRhbGljJDEsIExpbmskMSwgU3RyaWtlJDFdO1xuZnVuY3Rpb24gZ2V0TWFya2Rvd25TcGVjKGV4dGVuc2lvbikge1xuICB2YXIgX2V4dGVuc2lvbiRzdG9yYWdlLCBfbWFya2Rvd25FeHRlbnNpb25zJGY7XG4gIGNvbnN0IG1hcmtkb3duU3BlYyA9IChfZXh0ZW5zaW9uJHN0b3JhZ2UgPSBleHRlbnNpb24uc3RvcmFnZSkgPT09IG51bGwgfHwgX2V4dGVuc2lvbiRzdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXh0ZW5zaW9uJHN0b3JhZ2UubWFya2Rvd247XG4gIGNvbnN0IGRlZmF1bHRNYXJrZG93blNwZWMgPSAoX21hcmtkb3duRXh0ZW5zaW9ucyRmID0gbWFya2Rvd25FeHRlbnNpb25zLmZpbmQoKGUpID0+IGUubmFtZSA9PT0gZXh0ZW5zaW9uLm5hbWUpKSA9PT0gbnVsbCB8fCBfbWFya2Rvd25FeHRlbnNpb25zJGYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXJrZG93bkV4dGVuc2lvbnMkZi5zdG9yYWdlLm1hcmtkb3duO1xuICBpZiAobWFya2Rvd25TcGVjIHx8IGRlZmF1bHRNYXJrZG93blNwZWMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdE1hcmtkb3duU3BlYyxcbiAgICAgIC4uLm1hcmtkb3duU3BlY1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBNYXJrZG93blNlcmlhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCdAdGlwdGFwL2NvcmUnKS5FZGl0b3J9XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVkaXRvclwiLCBudWxsKTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoY29udGVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IE1hcmtkb3duU2VyaWFsaXplclN0YXRlKHRoaXMubm9kZXMsIHRoaXMubWFya3MsIHtcbiAgICAgIGhhcmRCcmVha05vZGVOYW1lOiBIYXJkQnJlYWskMS5uYW1lXG4gICAgfSk7XG4gICAgc3RhdGUucmVuZGVyQ29udGVudChjb250ZW50KTtcbiAgICByZXR1cm4gc3RhdGUub3V0O1xuICB9XG4gIGdldCBub2RlcygpIHtcbiAgICB2YXIgX3RoaXMkZWRpdG9yJGV4dGVuc2lvO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXModGhpcy5lZGl0b3Iuc2NoZW1hLm5vZGVzKS5tYXAoKG5hbWUpID0+IFtuYW1lLCB0aGlzLnNlcmlhbGl6ZU5vZGUoSFRNTE5vZGUpXSkpLFxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKChfdGhpcyRlZGl0b3IkZXh0ZW5zaW8gPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmV4dGVuc2lvbnMuZmlsdGVyKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi50eXBlID09PSBcIm5vZGVcIiAmJiB0aGlzLnNlcmlhbGl6ZU5vZGUoZXh0ZW5zaW9uKSkubWFwKChleHRlbnNpb24pID0+IFtleHRlbnNpb24ubmFtZSwgdGhpcy5zZXJpYWxpemVOb2RlKGV4dGVuc2lvbildKSkgIT09IG51bGwgJiYgX3RoaXMkZWRpdG9yJGV4dGVuc2lvICE9PSB2b2lkIDAgPyBfdGhpcyRlZGl0b3IkZXh0ZW5zaW8gOiBbXSlcbiAgICB9O1xuICB9XG4gIGdldCBtYXJrcygpIHtcbiAgICB2YXIgX3RoaXMkZWRpdG9yJGV4dGVuc2lvMjtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKHRoaXMuZWRpdG9yLnNjaGVtYS5tYXJrcykubWFwKChuYW1lKSA9PiBbbmFtZSwgdGhpcy5zZXJpYWxpemVNYXJrKEhUTUxNYXJrKV0pKSxcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcygoX3RoaXMkZWRpdG9yJGV4dGVuc2lvMiA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuZXh0ZW5zaW9ucy5maWx0ZXIoKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLnR5cGUgPT09IFwibWFya1wiICYmIHRoaXMuc2VyaWFsaXplTWFyayhleHRlbnNpb24pKS5tYXAoKGV4dGVuc2lvbikgPT4gW2V4dGVuc2lvbi5uYW1lLCB0aGlzLnNlcmlhbGl6ZU1hcmsoZXh0ZW5zaW9uKV0pKSAhPT0gbnVsbCAmJiBfdGhpcyRlZGl0b3IkZXh0ZW5zaW8yICE9PSB2b2lkIDAgPyBfdGhpcyRlZGl0b3IkZXh0ZW5zaW8yIDogW10pXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemVOb2RlKG5vZGUpIHtcbiAgICB2YXIgX2dldE1hcmtkb3duU3BlYztcbiAgICByZXR1cm4gKF9nZXRNYXJrZG93blNwZWMgPSBnZXRNYXJrZG93blNwZWMobm9kZSkpID09PSBudWxsIHx8IF9nZXRNYXJrZG93blNwZWMgPT09IHZvaWQgMCB8fCAoX2dldE1hcmtkb3duU3BlYyA9IF9nZXRNYXJrZG93blNwZWMuc2VyaWFsaXplKSA9PT0gbnVsbCB8fCBfZ2V0TWFya2Rvd25TcGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TWFya2Rvd25TcGVjLmJpbmQoe1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgIG9wdGlvbnM6IG5vZGUub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZU1hcmsobWFyaykge1xuICAgIHZhciBfZ2V0TWFya2Rvd25TcGVjMjtcbiAgICBjb25zdCBzZXJpYWxpemUgPSAoX2dldE1hcmtkb3duU3BlYzIgPSBnZXRNYXJrZG93blNwZWMobWFyaykpID09PSBudWxsIHx8IF9nZXRNYXJrZG93blNwZWMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TWFya2Rvd25TcGVjMi5zZXJpYWxpemU7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZSA/IHtcbiAgICAgIC4uLnNlcmlhbGl6ZSxcbiAgICAgIG9wZW46IHR5cGVvZiBzZXJpYWxpemUub3BlbiA9PT0gXCJmdW5jdGlvblwiID8gc2VyaWFsaXplLm9wZW4uYmluZCh7XG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIG9wdGlvbnM6IG1hcmsub3B0aW9uc1xuICAgICAgfSkgOiBzZXJpYWxpemUub3BlbixcbiAgICAgIGNsb3NlOiB0eXBlb2Ygc2VyaWFsaXplLmNsb3NlID09PSBcImZ1bmN0aW9uXCIgPyBzZXJpYWxpemUuY2xvc2UuYmluZCh7XG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIG9wdGlvbnM6IG1hcmsub3B0aW9uc1xuICAgICAgfSkgOiBzZXJpYWxpemUuY2xvc2VcbiAgICB9IDogbnVsbDtcbiAgfVxufVxuY2xhc3MgTWFya2Rvd25QYXJzZXIge1xuICBjb25zdHJ1Y3RvcihlZGl0b3IsIF9yZWYpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCdAdGlwdGFwL2NvcmUnKS5FZGl0b3J9XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVkaXRvclwiLCBudWxsKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bWFya2Rvd25pdH1cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWRcIiwgbnVsbCk7XG4gICAgbGV0IHtcbiAgICAgIGh0bWwsXG4gICAgICBsaW5raWZ5LFxuICAgICAgYnJlYWtzXG4gICAgfSA9IF9yZWY7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5tZCA9IHRoaXMud2l0aFBhdGNoZWRSZW5kZXJlcihtYXJrZG93bml0KHtcbiAgICAgIGh0bWwsXG4gICAgICBsaW5raWZ5LFxuICAgICAgYnJlYWtzXG4gICAgfSkpO1xuICB9XG4gIHBhcnNlKGNvbnRlbnQpIHtcbiAgICBsZXQge1xuICAgICAgaW5saW5lXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgIHZhciBfZ2V0TWFya2Rvd25TcGVjO1xuICAgICAgICByZXR1cm4gKF9nZXRNYXJrZG93blNwZWMgPSBnZXRNYXJrZG93blNwZWMoZXh0ZW5zaW9uKSkgPT09IG51bGwgfHwgX2dldE1hcmtkb3duU3BlYyA9PT0gdm9pZCAwIHx8IChfZ2V0TWFya2Rvd25TcGVjID0gX2dldE1hcmtkb3duU3BlYy5wYXJzZSkgPT09IG51bGwgfHwgX2dldE1hcmtkb3duU3BlYyA9PT0gdm9pZCAwIHx8IChfZ2V0TWFya2Rvd25TcGVjID0gX2dldE1hcmtkb3duU3BlYy5zZXR1cCkgPT09IG51bGwgfHwgX2dldE1hcmtkb3duU3BlYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldE1hcmtkb3duU3BlYy5jYWxsKHtcbiAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zXG4gICAgICAgIH0sIHRoaXMubWQpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZW5kZXJlZEhUTUwgPSB0aGlzLm1kLnJlbmRlcihjb250ZW50KTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50RnJvbVN0cmluZyhyZW5kZXJlZEhUTUwpO1xuICAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5leHRlbnNpb25zLmZvckVhY2goKGV4dGVuc2lvbikgPT4ge1xuICAgICAgICB2YXIgX2dldE1hcmtkb3duU3BlYzI7XG4gICAgICAgIHJldHVybiAoX2dldE1hcmtkb3duU3BlYzIgPSBnZXRNYXJrZG93blNwZWMoZXh0ZW5zaW9uKSkgPT09IG51bGwgfHwgX2dldE1hcmtkb3duU3BlYzIgPT09IHZvaWQgMCB8fCAoX2dldE1hcmtkb3duU3BlYzIgPSBfZ2V0TWFya2Rvd25TcGVjMi5wYXJzZSkgPT09IG51bGwgfHwgX2dldE1hcmtkb3duU3BlYzIgPT09IHZvaWQgMCB8fCAoX2dldE1hcmtkb3duU3BlYzIgPSBfZ2V0TWFya2Rvd25TcGVjMi51cGRhdGVET00pID09PSBudWxsIHx8IF9nZXRNYXJrZG93blNwZWMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0TWFya2Rvd25TcGVjMi5jYWxsKHtcbiAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zXG4gICAgICAgIH0sIGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5vcm1hbGl6ZURPTShlbGVtZW50LCB7XG4gICAgICAgIGlubGluZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIG5vcm1hbGl6ZURPTShub2RlLCBfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBpbmxpbmUsXG4gICAgICBjb250ZW50XG4gICAgfSA9IF9yZWYyO1xuICAgIHRoaXMubm9ybWFsaXplQmxvY2tzKG5vZGUpO1xuICAgIG5vZGUucXVlcnlTZWxlY3RvckFsbChcIipcIikuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIHZhciBfZWwkbmV4dFNpYmxpbmc7XG4gICAgICBpZiAoKChfZWwkbmV4dFNpYmxpbmcgPSBlbC5uZXh0U2libGluZykgPT09IG51bGwgfHwgX2VsJG5leHRTaWJsaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWwkbmV4dFNpYmxpbmcubm9kZVR5cGUpID09PSBOb2RlLlRFWFRfTk9ERSAmJiAhZWwuY2xvc2VzdChcInByZVwiKSkge1xuICAgICAgICBlbC5uZXh0U2libGluZy50ZXh0Q29udGVudCA9IGVsLm5leHRTaWJsaW5nLnRleHRDb250ZW50LnJlcGxhY2UoL15cXG4vLCBcIlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICB0aGlzLm5vcm1hbGl6ZUlubGluZShub2RlLCBjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgbm9ybWFsaXplQmxvY2tzKG5vZGUpIHtcbiAgICBjb25zdCBibG9ja3MgPSBPYmplY3QudmFsdWVzKHRoaXMuZWRpdG9yLnNjaGVtYS5ub2RlcykuZmlsdGVyKChub2RlMikgPT4gbm9kZTIuaXNCbG9jayk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBibG9ja3MubWFwKChibG9jaykgPT4ge1xuICAgICAgdmFyIF9ibG9jayRzcGVjJHBhcnNlRE9NO1xuICAgICAgcmV0dXJuIChfYmxvY2skc3BlYyRwYXJzZURPTSA9IGJsb2NrLnNwZWMucGFyc2VET00pID09PSBudWxsIHx8IF9ibG9jayRzcGVjJHBhcnNlRE9NID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYmxvY2skc3BlYyRwYXJzZURPTS5tYXAoKHNwZWMpID0+IHNwZWMudGFnKTtcbiAgICB9KS5mbGF0KCkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIsXCIpO1xuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgWy4uLm5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBpZiAoZWwucGFyZW50RWxlbWVudC5tYXRjaGVzKFwicFwiKSkge1xuICAgICAgICBleHRyYWN0RWxlbWVudChlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbm9ybWFsaXplSW5saW5lKG5vZGUsIGNvbnRlbnQpIHtcbiAgICB2YXIgX25vZGUkZmlyc3RFbGVtZW50Q2hpO1xuICAgIGlmICgoX25vZGUkZmlyc3RFbGVtZW50Q2hpID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZCkgIT09IG51bGwgJiYgX25vZGUkZmlyc3RFbGVtZW50Q2hpICE9PSB2b2lkIDAgJiYgX25vZGUkZmlyc3RFbGVtZW50Q2hpLm1hdGNoZXMoXCJwXCIpKSB7XG4gICAgICB2YXIgX2NvbnRlbnQkbWF0Y2gkLCBfY29udGVudCRtYXRjaCwgX2NvbnRlbnQkbWF0Y2gkMiwgX2NvbnRlbnQkbWF0Y2gyO1xuICAgICAgY29uc3QgZmlyc3RQYXJhZ3JhcGggPSBub2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgIH0gPSBmaXJzdFBhcmFncmFwaDtcbiAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gKF9jb250ZW50JG1hdGNoJCA9IChfY29udGVudCRtYXRjaCA9IGNvbnRlbnQubWF0Y2goL15cXHMrLykpID09PSBudWxsIHx8IF9jb250ZW50JG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29udGVudCRtYXRjaFswXSkgIT09IG51bGwgJiYgX2NvbnRlbnQkbWF0Y2gkICE9PSB2b2lkIDAgPyBfY29udGVudCRtYXRjaCQgOiBcIlwiO1xuICAgICAgY29uc3QgZW5kU3BhY2VzID0gIW5leHRFbGVtZW50U2libGluZyA/IChfY29udGVudCRtYXRjaCQyID0gKF9jb250ZW50JG1hdGNoMiA9IGNvbnRlbnQubWF0Y2goL1xccyskLykpID09PSBudWxsIHx8IF9jb250ZW50JG1hdGNoMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRlbnQkbWF0Y2gyWzBdKSAhPT0gbnVsbCAmJiBfY29udGVudCRtYXRjaCQyICE9PSB2b2lkIDAgPyBfY29udGVudCRtYXRjaCQyIDogXCJcIiA6IFwiXCI7XG4gICAgICBpZiAoY29udGVudC5tYXRjaCgvXlxcblxcbi8pKSB7XG4gICAgICAgIGZpcnN0UGFyYWdyYXBoLmlubmVySFRNTCA9IGAke2ZpcnN0UGFyYWdyYXBoLmlubmVySFRNTH0ke2VuZFNwYWNlc31gO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bndyYXBFbGVtZW50KGZpcnN0UGFyYWdyYXBoKTtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gYCR7c3RhcnRTcGFjZXN9JHtub2RlLmlubmVySFRNTH0ke2VuZFNwYWNlc31gO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHttYXJrZG93bml0fSBtZFxuICAgKi9cbiAgd2l0aFBhdGNoZWRSZW5kZXJlcihtZDIpIHtcbiAgICBjb25zdCB3aXRob3V0TmV3TGluZSA9IChyZW5kZXJlcikgPT4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCByZW5kZXJlZCA9IHJlbmRlcmVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVuZGVyZWQgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkO1xuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcmVkW3JlbmRlcmVkLmxlbmd0aCAtIDFdID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJlZC5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgfTtcbiAgICBtZDIucmVuZGVyZXIucnVsZXMuaGFyZGJyZWFrID0gd2l0aG91dE5ld0xpbmUobWQyLnJlbmRlcmVyLnJ1bGVzLmhhcmRicmVhayk7XG4gICAgbWQyLnJlbmRlcmVyLnJ1bGVzLnNvZnRicmVhayA9IHdpdGhvdXROZXdMaW5lKG1kMi5yZW5kZXJlci5ydWxlcy5zb2Z0YnJlYWspO1xuICAgIG1kMi5yZW5kZXJlci5ydWxlcy5mZW5jZSA9IHdpdGhvdXROZXdMaW5lKG1kMi5yZW5kZXJlci5ydWxlcy5mZW5jZSk7XG4gICAgbWQyLnJlbmRlcmVyLnJ1bGVzLmNvZGVfYmxvY2sgPSB3aXRob3V0TmV3TGluZShtZDIucmVuZGVyZXIucnVsZXMuY29kZV9ibG9jayk7XG4gICAgbWQyLnJlbmRlcmVyLnJlbmRlclRva2VuID0gd2l0aG91dE5ld0xpbmUobWQyLnJlbmRlcmVyLnJlbmRlclRva2VuLmJpbmQobWQyLnJlbmRlcmVyKSk7XG4gICAgcmV0dXJuIG1kMjtcbiAgfVxufVxuY29uc3QgTWFya2Rvd25DbGlwYm9hcmQgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogXCJtYXJrZG93bkNsaXBib2FyZFwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2Zvcm1QYXN0ZWRUZXh0OiBmYWxzZSxcbiAgICAgIHRyYW5zZm9ybUNvcGllZFRleHQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbbmV3IFBsdWdpbih7XG4gICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoXCJtYXJrZG93bkNsaXBib2FyZFwiKSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsaXBib2FyZFRleHRQYXJzZXI6ICh0ZXh0LCBjb250ZXh0LCBwbGFpblRleHQpID0+IHtcbiAgICAgICAgICBpZiAocGxhaW5UZXh0IHx8ICF0aGlzLm9wdGlvbnMudHJhbnNmb3JtUGFzdGVkVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZWRpdG9yLnN0b3JhZ2UubWFya2Rvd24ucGFyc2VyLnBhcnNlKHRleHQsIHtcbiAgICAgICAgICAgIGlubGluZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBET01QYXJzZXIuZnJvbVNjaGVtYSh0aGlzLmVkaXRvci5zY2hlbWEpLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcocGFyc2VkKSwge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuU2xpY2V9IHNsaWNlXG4gICAgICAgICAqL1xuICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKHNsaWNlKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudHJhbnNmb3JtQ29waWVkVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5zdG9yYWdlLm1hcmtkb3duLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHNsaWNlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSldO1xuICB9XG59KTtcbmNvbnN0IE1hcmtkb3duID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6IFwibWFya2Rvd25cIixcbiAgcHJpb3JpdHk6IDUwLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBodG1sOiB0cnVlLFxuICAgICAgdGlnaHRMaXN0czogdHJ1ZSxcbiAgICAgIHRpZ2h0TGlzdENsYXNzOiBcInRpZ2h0XCIsXG4gICAgICBidWxsZXRMaXN0TWFya2VyOiBcIi1cIixcbiAgICAgIGxpbmtpZnk6IGZhbHNlLFxuICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgIHRyYW5zZm9ybVBhc3RlZFRleHQ6IGZhbHNlLFxuICAgICAgdHJhbnNmb3JtQ29waWVkVGV4dDogZmFsc2VcbiAgICB9O1xuICB9LFxuICBhZGRDb21tYW5kcygpIHtcbiAgICBjb25zdCBjb21tYW5kcyA9IGV4dGVuc2lvbnMuQ29tbWFuZHMuY29uZmlnLmFkZENvbW1hbmRzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvbnRlbnQ6IChjb250ZW50LCBlbWl0VXBkYXRlLCBwYXJzZU9wdGlvbnMpID0+IChwcm9wcykgPT4ge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudChwcm9wcy5lZGl0b3Iuc3RvcmFnZS5tYXJrZG93bi5wYXJzZXIucGFyc2UoY29udGVudCksIGVtaXRVcGRhdGUsIHBhcnNlT3B0aW9ucykocHJvcHMpO1xuICAgICAgfSxcbiAgICAgIGluc2VydENvbnRlbnRBdDogKHJhbmdlLCBjb250ZW50LCBvcHRpb25zKSA9PiAocHJvcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdChyYW5nZSwgcHJvcHMuZWRpdG9yLnN0b3JhZ2UubWFya2Rvd24ucGFyc2VyLnBhcnNlKGNvbnRlbnQsIHtcbiAgICAgICAgICBpbmxpbmU6IHRydWVcbiAgICAgICAgfSksIG9wdGlvbnMpKHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBvbkJlZm9yZUNyZWF0ZSgpIHtcbiAgICB0aGlzLmVkaXRvci5zdG9yYWdlLm1hcmtkb3duID0ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnNcbiAgICAgIH0sXG4gICAgICBwYXJzZXI6IG5ldyBNYXJrZG93blBhcnNlcih0aGlzLmVkaXRvciwgdGhpcy5vcHRpb25zKSxcbiAgICAgIHNlcmlhbGl6ZXI6IG5ldyBNYXJrZG93blNlcmlhbGl6ZXIodGhpcy5lZGl0b3IpLFxuICAgICAgZ2V0TWFya2Rvd246ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnN0b3JhZ2UubWFya2Rvd24uc2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5lZGl0b3Iuc3RhdGUuZG9jKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZWRpdG9yLm9wdGlvbnMuaW5pdGlhbENvbnRlbnQgPSB0aGlzLmVkaXRvci5vcHRpb25zLmNvbnRlbnQ7XG4gICAgdGhpcy5lZGl0b3Iub3B0aW9ucy5jb250ZW50ID0gdGhpcy5lZGl0b3Iuc3RvcmFnZS5tYXJrZG93bi5wYXJzZXIucGFyc2UodGhpcy5lZGl0b3Iub3B0aW9ucy5jb250ZW50KTtcbiAgfSxcbiAgb25DcmVhdGUoKSB7XG4gICAgdGhpcy5lZGl0b3Iub3B0aW9ucy5jb250ZW50ID0gdGhpcy5lZGl0b3Iub3B0aW9ucy5pbml0aWFsQ29udGVudDtcbiAgICBkZWxldGUgdGhpcy5lZGl0b3Iub3B0aW9ucy5pbml0aWFsQ29udGVudDtcbiAgfSxcbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8vIHN0b3JhZ2Ugd2lsbCBiZSBkZWZpbmVkIGluIG9uQmVmb3JlQ3JlYXRlKCkgdG8gcHJldmVudCBpbml0aWFsIG9iamVjdCBvdmVycmlkaW5nXG4gICAgfTtcbiAgfSxcbiAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gW01hcmtkb3duVGlnaHRMaXN0cy5jb25maWd1cmUoe1xuICAgICAgdGlnaHQ6IHRoaXMub3B0aW9ucy50aWdodExpc3RzLFxuICAgICAgdGlnaHRDbGFzczogdGhpcy5vcHRpb25zLnRpZ2h0TGlzdENsYXNzXG4gICAgfSksIE1hcmtkb3duQ2xpcGJvYXJkLmNvbmZpZ3VyZSh7XG4gICAgICB0cmFuc2Zvcm1QYXN0ZWRUZXh0OiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtUGFzdGVkVGV4dCxcbiAgICAgIHRyYW5zZm9ybUNvcGllZFRleHQ6IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1Db3BpZWRUZXh0XG4gICAgfSldO1xuICB9XG59KTtcbmV4cG9ydCB7XG4gIE1hcmtkb3duXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlwdGFwLW1hcmtkb3duLmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tiptap-markdown/dist/tiptap-markdown.es.js\n");

/***/ })

};
;